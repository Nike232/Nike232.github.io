[{"title":"Vue基础学习笔记(一)","url":"/2025/07/19/Vue%E5%AD%A6%E4%B9%A0/Vue%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89/","content":"整体认识Vue3项目1、创建Vue3工程前置:NodeJS版本在18.0以上\n使用官方脚手架创建Vue工程:\nnpm create vue@latest#然后根据提示选择相关的组件\n\n启动项目:\nnpm install #安装相关依赖npmm run dev #运行项目\n\nTips:\n\n所有的功能组件都可以在后续手动添加\nnpm install之前可以尝试配置国内镜像，拉取会快一点npm config get registry https://registry.npmmirror.com\n\n2、主要工程结构建议使用vscode进行开发，原因是官方提供了辅助开发插件：vue(offcial)\n\n\n典型的vue项目，都是在index.html这个单页面中形成各种交互，也就是所谓的SPA\nvue3的核心是通过createApp函数创建一个应用实例，在这个实例中创建各种应用。\n每一个vue文件就是页面当中的一个组件，可以嵌套使用\nvue组件分为&lt;template&gt;页面模块，&lt;script&gt;脚本模块和&lt;style&gt;样式模块三个部分\n\n数据双向绑定双向绑定是vue最为核心的内容，简单理解就是&lt;template&gt;中的页面数据和&lt;script&gt;中的脚本数据进行绑定， 其中任何一个数据发生了变化，另外一个数据也随之发生变化。\n因此能实现让 UI 自动随着数据变化而更新，用户输入也能反向影响数据，非常适合开发交互性强的应用。\nVue 使用 v-model 指令实现双向绑定。\n一个简单例子:\n&lt;template&gt;  &lt;input v-model=&quot;name&quot; /&gt;  &lt;p&gt;你好，&#123;&#123; name &#125;&#125;&lt;/p&gt;&lt;/template&gt;&lt;script setup&gt;import &#123; ref &#125; from &#x27;vue&#x27;const name = ref(&#x27;小明&#x27;)&lt;/script&gt;\n\n其中ref是Vue3中用于创建响应式数据的函数，返回一个可以自动追踪变化并更新UI的对象\n然后通过v-model实现了输入框和name的双向绑定。\n其中&#123;&#123;name&#125;&#125;是Vue模板语法中的插值表达式，用于在HTML中显示JS的数据，也就是会将这里面的表达式求值然后渲染成结果。\n运行结果：\n\n","categories":["vue学习"],"tags":["vue基础"]},{"title":"Trie树","url":"/2025/07/14/%E7%AE%97%E6%B3%95/Trie%E6%A0%91/","content":"Trie树（又叫前缀树或字典树）是一种树形结构，专门用于高效地存储和查找字符串集合，特别适合处理前缀相关问题，如自动补全、字符串匹配、前缀计数等。\n代码模板:\n//以最经典的字符串为例//一般是要么全是大写要么全是小写，就可以轻松映射到26个数字之中int son[N][N],cnt[N],idx;// 0号点既是根节点，又是空节点// son[][]存储树中每个节点的子节点// cnt[]存储以每个节点结尾的单词数量//插入操作void insert(const char *str)&#123;    int p=0;//从根节点开始    for(int i=0;str[i];i++)    &#123;        int u=str[i]-&#x27;a&#x27;;//映射为数字        if(!son[p][u])son[p][u]=++idx;//如果不存在当前字符，就插入。注意要保留根节点的0        p=son[p][u];    &#125;    cnt[p]++;&#125;//查询操作int query(const char *str)&#123;    int p=0;    for(int i=0;str[i];i++)    &#123;        int u=str[i]-&#x27;a&#x27;;        if(!son[p][u])return 0;        p=son[p][u];    &#125;    return cnt[p];&#125;\n\n一道经典题目：最大异或数\n在给定的 N 个整数 A1，A2……AN 中选出两个进行 xor（异或）运算，得到的结果最大是多少？\n输入格式第一行输入一个整数 N。\n第二行输入 N 个整数 A1～AN。\n输出格式输出一个整数表示答案。\n数据范围1≤N≤105,0≤Ai&lt;231\n分析：很明显，需要把每一个整数拆成32位，然后逐步插入Trie树（这里就只有0和1两种了），所有处理完之后，我们对每一个数去找可能最大的异或数，然后取所有的最大值就好了。\n具体如果找异或数呢，其实也就是遍历数的过程，如果有跟当前位相反的，就直接取，否则就只能取0。\n#include&lt;iostream&gt;#include&lt;vector&gt;using namespace std;const int N=32*1e5+10;int son[N][2],idx;void insert(int x)&#123;    int p=0;    for(int i=31;i&gt;=0;i--)    &#123;        int bit=(x&gt;&gt;i)&amp;1;        if(!son[p][bit])son[p][bit]=++idx;        p=son[p][bit];    &#125;&#125;int main()&#123;    int n;scanf(&quot;%d&quot;,&amp;n);    vector&lt;int&gt;nums;    for(int i=0;i&lt;n;i++)&#123;        int x;scanf(&quot;%d&quot;,&amp;x);        insert(x);nums.push_back(x);    &#125;    int ans=0;    for(int x:nums)    &#123;        int sum=0;int p=0;        for(int i=31;i&gt;=0;i--)        &#123;            int bit=(x&gt;&gt;i)&amp;1;            int op=bit^1;            if(son[p][op])            &#123;                sum|=(1&lt;&lt;i);                p=son[p][op];            &#125;            else p=son[p][bit];        &#125;        ans=max(ans,sum);    &#125;    printf(&quot;%d&quot;,ans);&#125;\n\n","categories":["算法笔记"],"tags":["基础算法"]},{"title":"差分和前缀和算法","url":"/2025/07/18/%E7%AE%97%E6%B3%95/%E5%B7%AE%E5%88%86%E5%92%8C%E5%89%8D%E7%BC%80%E5%92%8C%E7%AE%97%E6%B3%95/","content":"首先声明，差分和前缀和都的下标都建议从1开始，本文中将采取这种方式。\n前缀和所谓前缀和算法，其实就是预处理从开头到某个下标为止的和，进而可以在O(1)的时间复杂度内快速求出[l,r]的和。\n一维前缀和S[i] = a[1] + a[2] + ... a[i]a[l] + ... + a[r] = S[r] - S[l - 1]\n\n二维前缀和S[i, j] = 第i行j列格子左上部分所有元素的和以(x1, y1)为左上角，(x2, y2)为右下角的子矩阵的和为：S[x2, y2] - S[x1 - 1, y2] - S[x2, y1 - 1] + S[x1 - 1, y1 - 1]\n\n差分所谓的差分其实是前缀和的逆操作\n差分数组的前缀和就是原数组\n差分的作用是将在[l,r]区间内所有数加c的操作转化为线性的对差分数组s[l]+c;s[r+1]-=c;的操作\n与前缀和不同的是，不用专门去求差分数组，只需要将差分数组初始化为0，然后去l&#x3D;r&#x3D;i然后加a[i]的操作的就可以了。\n一维差分给区间[l, r]中的每个数加上c：B[l] += c, B[r + 1] -= c\n\n二维差分给以(x1, y1)为左上角，(x2, y2)为右下角的子矩阵中的所有元素加上c：S[x1, y1] += c, S[x2 + 1, y1] -= c, S[x1, y2 + 1] -= c, S[x2 + 1, y2 + 1] += c\n\n","categories":["算法笔记"],"tags":["基础算法"]},{"title":"算竞中常用的无穷大--0x3f3f3f3f","url":"/2025/07/15/%E7%AE%97%E6%B3%95/%E7%AE%97%E7%AB%9E%E4%B8%AD%E5%B8%B8%E7%94%A8%E7%9A%84%E6%97%A0%E7%A9%B7%E5%A4%A7--0x3f3f3f3f/","content":"在算法竞赛中，我们常常需要用到设置一个常量用来代表“无穷大”。\n比如对于int类型的数，许多人会使用INT_MAX来表示无穷大，但同时也面临着一个问题，那就是只要加一就会溢出，特别是对于某些带有返回值用递归（特别是动态规划的一些题目）来求解的题目，那么意味着这个特殊值不能做任何的运算，必须采用特判，不仅代码复杂还容易出错。\n所以在算法竞赛中，常常使用0x3f3f3f3f来作为无穷大，主要有以下好处：\n0x3f3f3f3f的十进制为1061109567，和INT_MAX一个数量级，即10^9数量级，而一般场合下的数据都是小于10^9的。\n0x3f3f3f3f * 2 &#x3D; 2122219134，无穷大相加依然不会溢出。\n可以使用memset(array, 0x3f, sizeof(array))来为数组设初值为0x3f3f3f3f，因为这个数的每个字节都是0x3f。\n其中memset函数，需要注意，1.需要包含cstring头文件 2.是按字节进行赋值的\nps:常用的操作还有memset(array,-1,sizeof(array))因为-1是0xff，而0xffffffff也是-1，所以常常可以用来初始化一些数组，作为特殊信息。\n","categories":["算法笔记"],"tags":["算法细节"]},{"title":"背包问题","url":"/2025/07/20/%E7%AE%97%E6%B3%95/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/","content":"01背包问题有 N 件物品和一个容量是 V 的背包。每件物品只能使用一次。\n第 i 件物品的体积是 vi，价值是 wi。\n求解将哪些物品装入背包，可使这些物品的总体积不超过背包容量，且总价值最大。输出最大价值。\n分析：由于刚入门dp,所以我们从头到尾尽可能分析得详细（不会一来就写出优化的解法）。\n动态规划问题有两个关键，一是状态表示，二是状态转移\n就这道题而言，有两个变量，分别是v和w,所以我们先开一个二维数组来表示状态，f[i][j]所表示的状态是一个集合，这个集合里面就包括了所有的选法，但是f[i][j]最后是一个数，这个数表示集合的某种属性，集合的属性通常有三种，最大、最小和数量，这里很明显我们的属性应该表示为最大值，那么这个集合包括哪些选法呢？\n答案是在1-i个物品中选，然后总体积不超过j其实可以发现，就是把题目的最后要求的东西把常量换成变量就可以了（也就是相当于函数思想）。\n这个确定了，就要考虑如何把这个状态和其他状态联系起来，其实就是给集合分类，分类的标准是不重、不漏。这里我们可以分确定不选第i个物品的，和一定选第i个物品的。这就把集合中的选择分成两份了，对于前者其实就是f[i-1][j]那对于后者就是f[i-1][j-vi]+w[i]那么最后写出状态转移方程，就是两个中取较大的\n代码实现：\n#include&lt;iostream&gt;using namespace std;const int N=1010;int f[N][N];int v[N],w[N];int main()&#123;    int n,m;    cin&gt;&gt;n&gt;&gt;m;    for(int i=1;i&lt;=n;i++)cin&gt;&gt;v[i]&gt;&gt;w[i];    for(int i=1;i&lt;=n;i++)        for(int j=0;j&lt;=m;j++)&#123;            f[i][j]=f[i-1][j];            if(j&gt;=v[i])f[i][j]=max(f[i][j],f[i-1][j-v[i]]+w[i]);        &#125;    cout&lt;&lt;f[n][m];&#125;\n\n\n\n优化：我们可以注意到f[i]只和f[i-1]有关，也就是说使用滚动数组来做，进而意味着我们可以降为一维\n但是要注意，下面这种写法是错误的\nfor(int i=1;i&lt;=n;i++)    for(int j=v[i];j&lt;=m;j++)&#123;//j可以直接从v[i]开始        f[j]=max(f[j],f[j-v[i]]+w[i]]);    &#125;\n\n在f[j]没有更新的时候，f[j]里面存的就是上一次更新的值，也就是所谓的f[i-1][j]但是f[j-v[i]]就不是i-1次更新的值了，而是第i次更新的值，原因是j是递增的，但是j-v[i]一定是小于j的，也就是说在第i次更新j的时候，j-v[i]在这一轮一定已经更新了，所以不符合状态转移方程\n所以要倒序来遍历j，确保f[j-v[i]]是i-1下的状态\n优化代码：\n#include&lt;iostream&gt;using namespace std;const int N=1010;int v[N],w[N],f[N];int main()&#123;    int n,m;cin&gt;&gt;n&gt;&gt;m;    for(int i=1;i&lt;=n;i++)cin&gt;&gt;v[i]&gt;&gt;w[i];    for(int i=1;i&lt;=n;i++)        for(int j=m;j&gt;=v[i];j--)f[j]=max(f[j],f[j-v[i]]+w[i]);    cout&lt;&lt;f[m];&#125;\n\n完全背包问题在之前的分析的基础上，我们来应用到完全背包问题\n有 N 种物品和一个容量是 V 的背包，每种物品都有无限件可用。\n第 i 种物品的体积是 vi，价值是 wi。\n求解将哪些物品装入背包，可使这些物品的总体积不超过背包容量，且总价值最大。\n分析：状态的表示和01背包是一样的，状态转移也就是集合的划分不一样，我们之前是选和不选，这里我们就分成选0个，1个，2个……当然不可能是无限的，因为有限制\n朴素做法:\n#include&lt;iostream&gt;using namespace std;const int N=1010;int f[N][N],v[N],w[N];int main()&#123;    int n,m;cin&gt;&gt;n&gt;&gt;m;    for(int i=1;i&lt;=n;i++)cin&gt;&gt;v[i]&gt;&gt;w[i];    for(int i=1;i&lt;=n;i++)        for(int j=0;j&lt;=m;j++)            for(int k=0;k*v[i]&lt;=j;k++)                f[i][j]=max(f[i][j],f[i-1][j-k*v[i]]+k*w[i]);    cout&lt;&lt;f[n][m];&#125;\n\n\n进行优化，写出原始状态转移方程，然后找规律进行优化\n优化后代码：\n#include&lt;iostream&gt;using namespace std;const int N=1010;int f[N][N],v[N],w[N];int main()&#123;    int n,m;cin&gt;&gt;n&gt;&gt;m;    for(int i=1;i&lt;=n;i++)cin&gt;&gt;v[i]&gt;&gt;w[i];    for(int i=1;i&lt;=n;i++)        for(int j=0;j&lt;=m;j++)&#123;            f[i][j]=f[i-1][j];            if(j-v[i]&gt;=0)f[i][j]=max(f[i][j],f[i][j-v[i]]+w[i]);        &#125;    cout&lt;&lt;f[n][m];&#125;\n\n再进一步优化，可以压缩到一维，就要用到01背包那个错误例子，也就是算的是i，也就是正序遍历就可以了。\n#include&lt;iostream&gt;using namespace std;const int N=1010;int f[N],v[N],w[N];int main()&#123;    int n,m;cin&gt;&gt;n&gt;&gt;m;    for(int i=1;i&lt;=n;i++)cin&gt;&gt;v[i]&gt;&gt;w[i];    for(int i=1;i&lt;=n;i++)        for(int j=v[i];j&lt;=m;j++)&#123;            if(j-v[i]&gt;=0)f[j]=max(f[j],f[j-v[i]]+w[i]);        &#125;    cout&lt;&lt;f[m];&#125;\n\n","categories":["算法笔记"],"tags":["dp"]},{"title":"差分和前缀和刷题","url":"/2025/07/19/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/%E5%B7%AE%E5%88%86%E5%92%8C%E5%89%8D%E7%BC%80%E5%92%8C%E5%88%B7%E9%A2%98/","content":"中位数图好题指数：四星\n给出1~n的一个排列，统计该排列有多少个长度为奇数的连续子序列的中位数是b。中位数是指把所有元素从小到大排列后，位于中间的数。\n输入：第一行为两个正整数n和b\n输出：输出中位数为b的连续子序列的个数\n分析：这道题关键点是在于如何快速判断一个子序列中的中位数为b，对每一个子序列进行排序肯定不是最好的做法。假如一个连续子序列中的中位数为b，由于子序列的长度一定是奇数(2n+1)，也就是说只需要剩下有n个比b小，n个数比b大（因为是不重复的）。这就是问题的关键，也就是我们并不关心一个数的具体大小，而是只关心一个数比b大还是比b小，所以我们不妨对于比b大的数赋值为1，等于b的元素赋值为0，小于b的元素赋值为-1，因为只需要判断包含b并且和为0的子序列个数有多少，而子序列的和就自然用到前缀和去处理。\n第二个问题就是如果直接使用两重for循环会超时（因为限定时间为1s，而n最大时1e5)。所以同样要换个思路。这里的优化的思路其实和上面的思路差不多，那就是关注问题的本质而不是关注问题的细节，什么是问题的本质呢，也就是我们只需要在idx(b的索引)两边找到一个前缀和相同的两个索引（s[r]&#x3D;&#x3D;s[l-1]），关键在于我们只在乎个数，而不在乎具体是哪两个索引相等，如果我们跑去关注到底是哪两个索引，那肯定要枚举所有的情况然后去判断，就肯定会超时，这跟上面是一样的，如果我们去关注是具体的值而不是跟b的大小，也没有办法优化。所以一定要关注本质到底是什么。那么其实就是在idx左边找(l-1)分奇偶用哈希表存储个数，右边对应去哈希表查询。为什么要分奇偶呢？因为长度要是奇数个，也就是(r-l为偶数)那么r-(l-1)为奇数。这里有个细节，如果用数组去模拟哈希表的话要注意，存放的值是有正负的，但是索引一定要是正的，所以要加n\n代码实现：\n#include&lt;bits/stdc++.h&gt;#define js ios::sync_with_stdio(false);cin.tie(0);cout.tie(0)using namespace std;const int N=1e5+10;int a[N],s[N];int ji[2*N],ou[2*N];int main()&#123;    js;int idx;   int n,b;cin&gt;&gt;n&gt;&gt;b;    for(int i=1;i&lt;=n;i++)&#123;        int x;cin&gt;&gt;x;        if(x&gt;b)a[i]=1;        else if(x==b)a[i]=0,idx=i;        else a[i]=-1;    &#125;    //前缀和    for(int i=1;i&lt;=n;i++)s[i]=s[i-1]+a[i];    int res=0;    //用两重for循环去找会超时    //所以换个思路其实就是找奇偶相反的前缀和相等的坐标对    //s[r]-s[l-1]==0-&gt;s[r]==s[l-1];    for(int i=0;i&lt;idx;i++)    &#123;        if(i%2==0)ou[s[i]+n]++;        else ji[s[i]+n]++;    &#125;    for(int i=idx;i&lt;=n;i++)    &#123;        if(i%2==0)res+=ji[s[i]+n];        else res+=ou[s[i]+n];    &#125;    cout&lt;&lt;res;&#125;\n\n得到的经验：1.首先关注本质而不是细节 2.对于子序列（连续）问题的优化的关键往往是将区间转化为两个索引来降维\n二分好题指数：三星\n我们刚刚学了二分查找——所谓二分查找就是在一堆有序数里找某个符合要求的数。在学完二分查找之后如果让你玩猜数游戏（裁判选定一个目标数字，你说一个数裁判告诉你是高了还是低了直到你猜到那个数）的话，显然你会用二分的方式去猜。 \n  但是不是每一个玩猜数游戏的人都知道二分是最好，甚至一个健忘的玩家都有可能在得到裁判回答的下一个瞬间就忘了他之前问了什么以及裁判的回答），而现在更可怕的是，这个告诉你猜的数是高还是低的裁判他也很健忘，他总是薛定谔的记得这个目标数字，也就是说他的回答有可能出错。我们已经不关心这个不靠谱的游戏本身了，我们更关心裁判这个薛定谔的记得到底有几个是记得…… \n  现在给出这个健忘的玩家的所有猜测和裁判的所有回答，问裁判最多能有多少次是记得目标数字的，即裁判的回复是符合情况的。\n输入：\n第一行包含一个正整数n，表示裁判的回答数（也是玩家的猜数次数）。\n接下来n行，首先是猜的数，然后是一个空格，然后是一个符号。符号如果是“+”说明猜的数比答案大，“-”说明比答案小，“.”说明猜到了答案。\n输出：包含一个正整数，为裁判最多有多少个回答是正确的。\n分析：这道题第一个难点就在于如何求最多的正确次数，很明显由于目标数字其实是随意的，所以这道题其实是问存不存在一个数字能满足最多的回答情况，或者说是问所有的数字中，满足情况最多的数字的个数是多少。所以我们就不能从回答的真假性出发，而是认定每一句话都是正确的情况下，哪些数字满足。\n比如说5 ‘.’就是只有5满足，8 ‘+’就是小于8的数字都满足，那么每一个数字每满足一条就给他对应加1，这就相当于了在一个区间快速加减一个数，就转化成了差分的问题。但新的问题是，一共有-inf~inf这么多个数，肯定不可能开数组去做，所以肯定得离散化，所以使用map来存储。\n那么最后一个问题就是我们不可能遍历所有数然后求最值，但是事实上，我们也不需要，因为map中没有记录的值那一定是0，什么意思呢？就比如map[1]&#x3D;2 map[5]&#x3D;-1 那么对于s[1]&#x3D;map[1]+s[0]，那么s[2]&#x3D;s[1]+map[0]但是map[0]没有记录就说明他是0，说明s[2]&#x3D;s1同样的道理，1-5之间的所有数（也就是相邻两个记录的数之间都是一样的）那我们只关注最大的值是多少，不关注具体是哪一个，所以我们只需要遍历map就可以解决问题了。\n代码实现：\n#include&lt;bits/stdc++.h&gt;using namespace std;const int inf=INT_MAX;map&lt;int,int&gt;M;int main()&#123;    ios::sync_with_stdio(false);cin.tie(0);cout.tie(0);    int n;cin&gt;&gt;n;    for(int i=1;i&lt;=n;i++)    &#123;        int x;char ch;cin&gt;&gt;x&gt;&gt;ch;        if(ch==&#x27;.&#x27;)M[x]++,M[x+1]--;        else if(ch==&#x27;+&#x27;)M[-inf]++,M[x]--;        else M[x+1]++,M[inf]--;    &#125;    int res=0;int h=0;    for(auto x:M)    &#123;        h+=x.second;        res=max(res,h);    &#125;    cout&lt;&lt;res;&#125;\n\n","categories":["算法刷题"],"tags":["基础算法"]}]