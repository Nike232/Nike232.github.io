[{"title":"Vue基础学习笔记(一)","url":"/2025/07/19/Vue%E5%AD%A6%E4%B9%A0/Vue%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89/","content":"整体认识Vue3项目1、创建Vue3工程前置:NodeJS版本在18.0以上\n使用官方脚手架创建Vue工程:\nnpm create vue@latest#然后根据提示选择相关的组件\n\n启动项目:\nnpm install #安装相关依赖npmm run dev #运行项目\n\nTips:\n\n所有的功能组件都可以在后续手动添加\nnpm install之前可以尝试配置国内镜像，拉取会快一点npm config get registry https://registry.npmmirror.com\n\n2、主要工程结构建议使用vscode进行开发，原因是官方提供了辅助开发插件：vue(offcial)\n\n\n典型的vue项目，都是在index.html这个单页面中形成各种交互，也就是所谓的SPA\nvue3的核心是通过createApp函数创建一个应用实例，在这个实例中创建各种应用。\n每一个vue文件就是页面当中的一个组件，可以嵌套使用\nvue组件分为&lt;template&gt;页面模块，&lt;script&gt;脚本模块和&lt;style&gt;样式模块三个部分\n\n数据双向绑定双向绑定是vue最为核心的内容，简单理解就是&lt;template&gt;中的页面数据和&lt;script&gt;中的脚本数据进行绑定， 其中任何一个数据发生了变化，另外一个数据也随之发生变化。\n因此能实现让 UI 自动随着数据变化而更新，用户输入也能反向影响数据，非常适合开发交互性强的应用。\nVue 使用 v-model 指令实现双向绑定。\n一个简单例子:\n&lt;template&gt;  &lt;input v-model=&quot;name&quot; /&gt;  &lt;p&gt;你好，&#123;&#123; name &#125;&#125;&lt;/p&gt;&lt;/template&gt;&lt;script setup&gt;import &#123; ref &#125; from &#x27;vue&#x27;const name = ref(&#x27;小明&#x27;)&lt;/script&gt;\n\n其中ref是Vue3中用于创建响应式数据的函数，返回一个可以自动追踪变化并更新UI的对象\n然后通过v-model实现了输入框和name的双向绑定。\n其中&#123;&#123;name&#125;&#125;是Vue模板语法中的插值表达式，用于在HTML中显示JS的数据，也就是会将这里面的表达式求值然后渲染成结果。\n运行结果：\n\n","categories":["vue学习"],"tags":["vue基础"]},{"title":"Trie树","url":"/2025/07/14/%E7%AE%97%E6%B3%95/Trie%E6%A0%91/","content":"Trie树（又叫前缀树或字典树）是一种树形结构，专门用于高效地存储和查找字符串集合，特别适合处理前缀相关问题，如自动补全、字符串匹配、前缀计数等。\n代码模板:\n//以最经典的字符串为例//一般是要么全是大写要么全是小写，就可以轻松映射到26个数字之中int son[N][N],cnt[N],idx;// 0号点既是根节点，又是空节点// son[][]存储树中每个节点的子节点// cnt[]存储以每个节点结尾的单词数量//插入操作void insert(const char *str)&#123;    int p=0;//从根节点开始    for(int i=0;str[i];i++)    &#123;        int u=str[i]-&#x27;a&#x27;;//映射为数字        if(!son[p][u])son[p][u]=++idx;//如果不存在当前字符，就插入。注意要保留根节点的0        p=son[p][u];    &#125;    cnt[p]++;&#125;//查询操作int query(const char *str)&#123;    int p=0;    for(int i=0;str[i];i++)    &#123;        int u=str[i]-&#x27;a&#x27;;        if(!son[p][u])return 0;        p=son[p][u];    &#125;    return cnt[p];&#125;\n\n一道经典题目：最大异或数\n在给定的 N 个整数 A1，A2……AN 中选出两个进行 xor（异或）运算，得到的结果最大是多少？\n输入格式第一行输入一个整数 N。\n第二行输入 N 个整数 A1～AN。\n输出格式输出一个整数表示答案。\n数据范围1≤N≤105,0≤Ai&lt;231\n分析：很明显，需要把每一个整数拆成32位，然后逐步插入Trie树（这里就只有0和1两种了），所有处理完之后，我们对每一个数去找可能最大的异或数，然后取所有的最大值就好了。\n具体如果找异或数呢，其实也就是遍历数的过程，如果有跟当前位相反的，就直接取，否则就只能取0。\n#include&lt;iostream&gt;#include&lt;vector&gt;using namespace std;const int N=32*1e5+10;int son[N][2],idx;void insert(int x)&#123;    int p=0;    for(int i=31;i&gt;=0;i--)    &#123;        int bit=(x&gt;&gt;i)&amp;1;        if(!son[p][bit])son[p][bit]=++idx;        p=son[p][bit];    &#125;&#125;int main()&#123;    int n;scanf(&quot;%d&quot;,&amp;n);    vector&lt;int&gt;nums;    for(int i=0;i&lt;n;i++)&#123;        int x;scanf(&quot;%d&quot;,&amp;x);        insert(x);nums.push_back(x);    &#125;    int ans=0;    for(int x:nums)    &#123;        int sum=0;int p=0;        for(int i=31;i&gt;=0;i--)        &#123;            int bit=(x&gt;&gt;i)&amp;1;            int op=bit^1;            if(son[p][op])            &#123;                sum|=(1&lt;&lt;i);                p=son[p][op];            &#125;            else p=son[p][bit];        &#125;        ans=max(ans,sum);    &#125;    printf(&quot;%d&quot;,ans);&#125;\n\n","categories":["算法笔记"],"tags":["基础算法"]},{"title":"差分和前缀和算法","url":"/2025/07/18/%E7%AE%97%E6%B3%95/%E5%B7%AE%E5%88%86%E5%92%8C%E5%89%8D%E7%BC%80%E5%92%8C%E7%AE%97%E6%B3%95/","content":"首先声明，差分和前缀和都的下标都建议从1开始，本文中将采取这种方式。\n前缀和所谓前缀和算法，其实就是预处理从开头到某个下标为止的和，进而可以在O(1)的时间复杂度内快速求出[l,r]的和。\n一维前缀和S[i] = a[1] + a[2] + ... a[i]a[l] + ... + a[r] = S[r] - S[l - 1]\n\n二维前缀和S[i, j] = 第i行j列格子左上部分所有元素的和以(x1, y1)为左上角，(x2, y2)为右下角的子矩阵的和为：S[x2, y2] - S[x1 - 1, y2] - S[x2, y1 - 1] + S[x1 - 1, y1 - 1]\n\n差分所谓的差分其实是前缀和的逆操作\n差分数组的前缀和就是原数组\n差分的作用是将在[l,r]区间内所有数加c的操作转化为线性的对差分数组s[l]+c;s[r+1]-=c;的操作\n与前缀和不同的是，不用专门去求差分数组，只需要将差分数组初始化为0，然后去l&#x3D;r&#x3D;i然后加a[i]的操作的就可以了。\n一维差分给区间[l, r]中的每个数加上c：B[l] += c, B[r + 1] -= c\n\n二维差分给以(x1, y1)为左上角，(x2, y2)为右下角的子矩阵中的所有元素加上c：S[x1, y1] += c, S[x2 + 1, y1] -= c, S[x1, y2 + 1] -= c, S[x2 + 1, y2 + 1] += c\n\n","categories":["算法笔记"],"tags":["基础算法"]},{"title":"差分和前缀和刷题","url":"/2025/07/19/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/%E5%B7%AE%E5%88%86%E5%92%8C%E5%89%8D%E7%BC%80%E5%92%8C%E5%88%B7%E9%A2%98/","content":"中位数图好题指数：四星\n给出1~n的一个排列，统计该排列有多少个长度为奇数的连续子序列的中位数是b。中位数是指把所有元素从小到大排列后，位于中间的数。\n输入：第一行为两个正整数n和b\n输出：输出中位数为b的连续子序列的个数\n分析：这道题关键点是在于如何快速判断一个子序列中的中位数为b，对每一个子序列进行排序肯定不是最好的做法。假如一个连续子序列中的中位数为b，由于子序列的长度一定是奇数(2n+1)，也就是说只需要剩下有n个比b小，n个数比b大（因为是不重复的）。这就是问题的关键，也就是我们并不关心一个数的具体大小，而是只关心一个数比b大还是比b小，所以我们不妨对于比b大的数赋值为1，等于b的元素赋值为0，小于b的元素赋值为-1，因为只需要判断包含b并且和为0的子序列个数有多少，而子序列的和就自然用到前缀和去处理。\n第二个问题就是如果直接使用两重for循环会超时（因为限定时间为1s，而n最大时1e5)。所以同样要换个思路。这里的优化的思路其实和上面的思路差不多，那就是关注问题的本质而不是关注问题的细节，什么是问题的本质呢，也就是我们只需要在idx(b的索引)两边找到一个前缀和相同的两个索引（s[r]&#x3D;&#x3D;s[l-1]），关键在于我们只在乎个数，而不在乎具体是哪两个索引相等，如果我们跑去关注到底是哪两个索引，那肯定要枚举所有的情况然后去判断，就肯定会超时，这跟上面是一样的，如果我们去关注是具体的值而不是跟b的大小，也没有办法优化。所以一定要关注本质到底是什么。那么其实就是在idx左边找(l-1)分奇偶用哈希表存储个数，右边对应去哈希表查询。为什么要分奇偶呢？因为长度要是奇数个，也就是(r-l为偶数)那么r-(l-1)为奇数。这里有个细节，如果用数组去模拟哈希表的话要注意，存放的值是有正负的，但是索引一定要是正的，所以要加n\n代码实现：\n#include&lt;bits/stdc++.h&gt;#define js ios::sync_with_stdio(false);cin.tie(0);cout.tie(0)using namespace std;const int N=1e5+10;int a[N],s[N];int ji[2*N],ou[2*N];int main()&#123;    js;int idx;   int n,b;cin&gt;&gt;n&gt;&gt;b;    for(int i=1;i&lt;=n;i++)&#123;        int x;cin&gt;&gt;x;        if(x&gt;b)a[i]=1;        else if(x==b)a[i]=0,idx=i;        else a[i]=-1;    &#125;    //前缀和    for(int i=1;i&lt;=n;i++)s[i]=s[i-1]+a[i];    int res=0;    //用两重for循环去找会超时    //所以换个思路其实就是找奇偶相反的前缀和相等的坐标对    //s[r]-s[l-1]==0-&gt;s[r]==s[l-1];    for(int i=0;i&lt;idx;i++)    &#123;        if(i%2==0)ou[s[i]+n]++;        else ji[s[i]+n]++;    &#125;    for(int i=idx;i&lt;=n;i++)    &#123;        if(i%2==0)res+=ji[s[i]+n];        else res+=ou[s[i]+n];    &#125;    cout&lt;&lt;res;&#125;\n\n得到的经验：1.首先关注本质而不是细节 2.对于子序列（连续）问题的优化的关键往往是将区间转化为两个索引来降维\n","categories":["算法刷题"],"tags":["基础算法"]},{"title":"算竞中常用的无穷大--0x3f3f3f3f","url":"/2025/07/15/%E7%AE%97%E6%B3%95/%E7%AE%97%E7%AB%9E%E4%B8%AD%E5%B8%B8%E7%94%A8%E7%9A%84%E6%97%A0%E7%A9%B7%E5%A4%A7--0x3f3f3f3f/","content":"在算法竞赛中，我们常常需要用到设置一个常量用来代表“无穷大”。\n比如对于int类型的数，许多人会使用INT_MAX来表示无穷大，但同时也面临着一个问题，那就是只要加一就会溢出，特别是对于某些带有返回值用递归（特别是动态规划的一些题目）来求解的题目，那么意味着这个特殊值不能做任何的运算，必须采用特判，不仅代码复杂还容易出错。\n所以在算法竞赛中，常常使用0x3f3f3f3f来作为无穷大，主要有以下好处：\n0x3f3f3f3f的十进制为1061109567，和INT_MAX一个数量级，即10^9数量级，而一般场合下的数据都是小于10^9的。\n0x3f3f3f3f * 2 &#x3D; 2122219134，无穷大相加依然不会溢出。\n可以使用memset(array, 0x3f, sizeof(array))来为数组设初值为0x3f3f3f3f，因为这个数的每个字节都是0x3f。\n其中memset函数，需要注意，1.需要包含cstring头文件 2.是按字节进行赋值的\nps:常用的操作还有memset(array,-1,sizeof(array))因为-1是0xff，而0xffffffff也是-1，所以常常可以用来初始化一些数组，作为特殊信息。\n","categories":["算法笔记"],"tags":["算法细节"]}]